Введение

Мы с вами узнали, чем полезны юнит-тесты, а также как их создавать. Кроме того мы создали собственный юнит-тест фреймворк. Напомним, что целью его создания было:
- продемонстрировать, как с помощью различных возможностей языка C++ придавать программе необходимые свойства,
- дать вам понимание того, как устроен юнит-тест фреймворк,
- дать вам возможность изменять его, делая более удобным для себя

Теперь мы предлагаем вам ряд заданий по программированию, которые позволят вам попрактиковаться в написании юнит-тестов и работе с юнит-тест фреймворком. В каждой задаче вам будет выдан интерфейс (функция или класс), который надо будет покрыть юнит-тестами. Ваши тесты должны будут проверять, что интерфейс реализован правильно, то есть он корректно обрабатывает входные данные. Заметим, что в наших задачах вам достаточно будет протестировать корректность работы — тестировать производительность не нужно.

Как мы проверяем ваши посылки

В заданиях на тестирование вы должны прислать cpp-файл с юнит-тестами для заданного интерфейса. У нас есть правильные и неправильные реализации интерфейса. Мы по очереди компилируем ваш файл с каждой из них и запускаем получившийся исполняемый файл. Если программа вернула нулевой код возврата, мы считаем, что ваши тесты признали реализацию корректной. Если программа завершилась с ненулевым кодом возврата, значит, ваши тесты признали реализацию некорректной. Соответственно ваши тесты должны принимать правильные реализации интерфейса и отвергать неправильные.

Если ваши тесты приняли неправильную реализацию или отвергли правильную, автоматическая система проверки пришлёт вам stderr вашей программы. Его анализ может помочь вам понять, как ведёт себя реализация, для которой ваши тесты отработали неверно. Поэтому вы можете выводить туда имена прошедших и упавших тестов, результаты вызова тестируемых функций и т.д. (наш юнит-тест фреймворк уже умеет выводить эту информацию).

Как писать юнит-тесты

Мы предлагаем вам воспользоваться юнит-тест фреймворком, который мы разработали в видеолекциях. Метод RunTest класса TestRunner для каждого теста сообщает в stderr, прошёл он или нет. Функции Assert и AssertEqual выводят в stderr свои аргументы, если они оказались не равны.

Но, как было сказано выше, автоматическая проверяющая система смотрит только на код возврата вашей программы, поэтому вы можете изменять наш фреймворк или не пользоваться им вообще.

Пример

Давайте рассмотрим пример задачи.

Разработайте юнит-тесты для функции uint32_t Div(uint32_t a, uint32_t b). Функция Div возвращает частное от деления параметра a на b. Если b == 0, то функция Div возвращает numeric_limits<uint32_t>::max().

Решение этой задачи могло бы выглядеть так:
#include ...
#include ...

/*
 * Здесь идёт код тестового фреймворка: AssertEqual, Assert, TestRunner и т.д.
 */

void TestDiv() {
    AssertEqual(Div(10, 2), 5);
    AssertEqual(Div(3, 2), 1);
}

int main() {
    TestRunner tr;
    tr.RunTest(TestDiv, "TestDiv");
    return 0;
}

Если мы отправим этот код в тестирующую систему, то он не будет принят, а в ответ мы получим сообщение "Wrong implementation was accepted by tests: TestDiv OK". Оно означает, что наши тесты приняли некорректную реализацию функции Div. Так и есть — наши тесты принимают реализацию, которая никак не обрабатывает деление на ноль:
int Div(int a, int b) {
    return a / b;
}

Давайте учтём это в наших тестах:
#include ...
#include ...

/*
 * Здесь идёт код тестового фреймворка: AssertEqual, Assert, TestRunner и т.д.
 */

void TestDiv() {
    AssertEqual(Div(10, 2), 5);
    AssertEqual(Div(3, 2), 1);
}

void TestDivisionByZero() {
    AssertEqual(Div(10, 0), numeric_limits<uint32_t>::max());
}

int main() {
    TestRunner tr;
    tr.RunTest(TestDiv, "TestDiv");
    tr.RunTest(TestDivisionByZero, "TestDivisionByZero");
    return 0;
}

Если мы отправим эти тесты в проверяющую систему, они будут ею приняты.
