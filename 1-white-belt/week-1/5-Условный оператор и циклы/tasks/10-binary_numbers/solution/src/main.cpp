#include <cstdlib>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/*
 * На вход дано целое положительное число N.
 * Вывести его в двоичной с-ме счисления без ведущих нулей.
 * Тестовые данные:
 * 5  => 101
 * 32 => 100000
 * 1  => 1
 * 
 * Алгоритм работы:
 * 1) Число n делится на основание р;
 * 2) Полученный остаток запоминается или записывается (это б/цифра младшего разряда;
 * 3) Целая часть полцченного частного снова делится на р;
 * 4) Опять запоминаем полцченный остаток (это б/цифра след. разряда).
 * Такое последовательное деление продолжается до тех пор, пока целая часть
 * частного не окажется меньше, чем основание с-мы счисления р. Эта последняя 
 * целая часть частного б/цифрой старшего разряда. Рез-т формируется путем
 * последовательной записи слева направо цифры старшего разряда и всех 
 * записанных остатков в порядке, обратном их получению.
 * Подсказка: число N можно считывать в переменную типа int
 * алгоритм перевода из десятичной системы счисления в двоичную, может быть найден, например, здесь: 
 * https://www.yaklass.ru/p/informatika/10-klass/informatciia-i-informatcionnye-protcessy-11955/predstavlenie-chislovoi-informatcii-v-kompiutere-11901/re-62e8903e-ba93-478a-85b5-ae45af40c658
 * в этой задаче вам может пригодиться контейнер vector; напоминаем, что добавление значения x в конец вектора v делается так: v.push_back(x);

 * Альтернативное решение
 * #include <bitset>
 * int N = 0, B = 0;
 * cin >> N;
 * bitset<64> mybitset(N);
 * string mystring = mybitset.to_string<char, string::traits_type, string::allocator_type>();
 */
int main(int argc, char** argv) {
    int n = 0;            //  вводимое число
    int base = 0;         //  основание
    int remainder = 0;    //  остаток от деления числа на основание
    vector <int> vec;     //  сюда записываем остатки от деления

    cin >> n >> base;    
    while (n >= 1)
    {
        remainder = n % base;
        n = n/base;
        vec.push_back(remainder);
        cout << "n = " << n << " n % base = " << remainder << endl;
       
    }
    //for (int i = vec.size() - 1; i >= 0; i--)
    //    cout << vec[i];
    
    //  Поменяли порядок вывода вектора
    reverse(begin(vec), end(vec));
    /* 
     * Выводим вектор по константной ссылке. Так мы не тратим ресурсы на 
     * копирование и не допускаем риска изменения индекса
     */
    for (const auto& i : vec)
    {
        cout << i;
    }
    

    return 0;
}

