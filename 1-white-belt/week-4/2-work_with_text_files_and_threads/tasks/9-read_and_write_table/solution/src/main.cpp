#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <iomanip>		//	библиотека для потоковых манипуляторов
using namespace std;

/*
В первой строке файла input.txt записаны 2 числа N и M.
Далее в файле находится таблица из N строк и M столбцов, представленная в формате
CSV (comma-separated values). Такой формат часто исп-ся для текстового представления
таблиц с данными: в файле несколько строк, значения из разных ячеек внутри строки 
отделены друг от друга запятыми.

Задача: вывести данные на экран в виде таблицы. Формат таблицы:
1) размер ячейки = 10,
2) соседние ячейки отделены друг от друга пробелом,
3) последняя ячейка в строке НЕ оканчивается пробелом, 
4) последняя строка НЕ оканчивается символом перевода строки.
Гарантируется, что в таблице будет ровно N строк и M столбцов, 
значение к-дой из ячеек - целое число. Пример ввода:
2 3
1,2,3
4,5,6

Пример вывода:
1	2	3
4	5	6
*/

/*
Читает файл поблочно до разделителя и выводит на экран прочитанное
Принимает на вход путь к файлу и разделитель
*/
void ReadOutMatrix (const string& path, int width)
{
	ifstream input (path);	//	для считывание файла создаем поток
	string line;	//	строка, в к-рую б/считываться содержимое фала
	int rows = 0;
	int cols = 0;
	int matrixEl = 0;

	if (input)
	{
		input >> rows;
		input.ignore(1);
		input >> cols;
		input.ignore(1);
		cout << rows << ' ' << cols << ' ' << endl;

		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < cols; j++)
			{
				input >> matrixEl;
				cout << setw(width) << matrixEl << ' ';	//	соседние ячейки отделены друг от друга пробелом и размер ячейки = 10
				if (j < cols)	//	последняя ячейка в строке НЕ оканчивается пробелом
					input.ignore(1);
			}
			if (i < rows)	 //	последняя строка НЕ оканчивается символом перевода строки
				cout << endl;
		}
	}
	else 
	{
		cout << "Error open file" << endl;
	}
}

int main()
{
	const string inputPath = "input.txt";
	int width = 10;
	cout << left;	//	выравнивание данных по левому краю
	ReadOutMatrix(inputPath, width);

	return 0;
}

