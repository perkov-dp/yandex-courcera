/*
Cловари м/создавать указываЯ конкретные значения пары ключ-значение.
Љлючи формируютсЯ лексикографически и они уникальны.
*/
//  м/создавать указываЯ конкретные значения пары ключ-значение
map<string, int> m = {{"one", 1}, {"two", 2}, {"three", 3}};

//	м/удалЯть эл-ты словарЯ по их ключу
m.erase("three");

void PrintMap (const map <string, int>& m)
{
	for (const auto& item : m)
	{
		cout << item.first << ": " << item.second << endl;
	}
	/*
	добавили константную ссылку в цикл for длЯ того, чтобы перестать копировать 
	пару ключ-значение в переменную item.
	’еперь компилЯтор б/видеть, что здесь теперь здесь константнаЯ ссылка на какой-то тип, на пару из ключча и значениЯ
	*/
}

//	есть набор в-ров слов. Њы можем посчитать сколько раз встречаетсЯ каждое слово
vector <string> words = {"one", "two", "one"};
//	исп-ем словарь из строк в целые числа. Ѓ/хранить к-дое слово и сколько раз оно встречаетсЯ
map <string, int> counters;
//	заполнЯем словарь. „лЯ этого итерируемсЯ константной ссылкой по всем словам чтобы лишний раз не копироватьь в переменную word
for (const string& word : words)
{
	//	н/обновить значениЯ counters от words
	//	как мы это д/сделать? Ќ/проверить, есть ли такой ключ в словаре с пом-щью метода count, к-рый возвращает 
	//	сколько раз этот ключ встречаетсЯ в словаре. поскольку ключ уникальный, то б/ноль или один
	if (counters.count(word) == 0)	//	если этого ключа еще нет, то мы д/добавить его в словарь со значением 1
	{
		counters[word] = 1
	}
	else	//	у нас уже есть такой ключ и мы можем увеличить его значение
	{
		++counters[word];
	}
}
//	оказываетсЯ этот код избыточен

for (const string& word : words)
{
	++counters[word];
	//	как только мы обратились к конкретному эл-ту словарЯ с пом-щью [], то компилЯтору н/создать эту пару из ключа и значениЯ по умолчанию
	//	‚ данном случае, если мы обращаемсЯ к какому-то ключу и он существует, то возвращаетсЯ ссылка на него и мы увеличиваем значение на 1.
	//	…сли такого ключа еще не было, то он добавлЯетсЯ со значением 0, т.к. целое чсло по умолчанию - это ноль.
	//	’.е. от обращениЯ к несуществующему ключу, размер словарЯ м/увеличитьсЯ
}

//	Џђ€Њ…ђ
//	‘группируем слова в каком-то наборе по первой букве. Љлючом б/перваЯ буква
vector <string> words = {"one", "two", "three"};
map <char, vector <string>> grouped_words;
//	‡аполнЯем словарь, проходЯ по всем словам
for (const string& word : words)
{
	//	„лЯ к-го слова н/взЯть первую букву, по к-рой б/группировать, обратитьсЯ к соответствующему ключу словарЯ
	grouped_words[word[0]].push_back(word);
	//	и поскольку от одного такого обращениЯ этот ключ добавитсЯ в словарь, если его там еще не было с пустым в-ром,
	//	т.к. в-р по умолчанию - пустой в-р, то м/сразу сделать push_back от слова word
}
//	выведем словарь с группированными значениЯми на экран
//	перебираем все пары ключ-значениЯ в этом словаре
for (const auto& item : words)
{
	//	ключ - это символ. Ћн лежит в поле first
	cout << item.first << endl;
	//	затем выводим все слова, к-рые соответствуют этому ключу
	//	„лЯ этого н/проитерироватьсЯ по всем словам из значениЯ большого словарЯ, а значениЯ больщого словарЯ - item.second
	for (const string& word : item.second)
		cout << word << " ";
	cout << endl;
	//	‚ывод:
	//	ключ o - значение one с в-ром длины 1
	//	ключ t - значениЯ two three с в-ром длины 2
}